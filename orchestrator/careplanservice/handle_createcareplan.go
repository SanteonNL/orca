package careplanservice

import (
	"fmt"
	"net/http"
	"strings"

	"github.com/SanteonNL/orca/orchestrator/lib/coolfhir"
	"github.com/SanteonNL/orca/orchestrator/lib/to"
	"github.com/google/uuid"
	"github.com/rs/zerolog/log"
	"github.com/samply/golang-fhir-models/fhir-models/fhir"
)

func (s *Service) handleCreateCarePlan(httpResponse http.ResponseWriter, httpRequest *http.Request) error {
	log.Info().Msg("Creating CarePlan")
	// TODO: Authorize request here
	// TODO: Check only allowed fields are set, or only the allowed values (INT-204)?
	var carePlan fhir.CarePlan
	if err := s.readRequest(httpRequest, &carePlan); err != nil {
		return fmt.Errorf("invalid %T: %w", carePlan, err)
	}
	// Reset CarePlan.Id to nil to ensure it is generated by the server
	carePlan.Id = nil

	careTeamURL := "urn:uuid:" + uuid.NewString()
	careTeam := fhir.CareTeam{}
	carePlan.CareTeam = append(carePlan.CareTeam, fhir.Reference{
		Reference: to.Ptr(careTeamURL),
		Type:      to.Ptr(coolfhir.ResourceType(careTeam)),
	})

	bundle := coolfhir.Transaction().
		Create(carePlan).
		Create(careTeam, coolfhir.WithFullUrl(careTeamURL)).
		Bundle()

	if _, err := coolfhir.ExecuteTransactionAndRespondWithEntry(s.fhirClient, bundle, func(entry fhir.BundleEntry) bool {
		return entry.Response.Location != nil && strings.HasPrefix(*entry.Response.Location, "CarePlan/")
	}, httpResponse); err != nil {
		return fmt.Errorf("failed to create CarePlan and CareTeam: %w", err)
	}
	return nil
}
