package careplanservice

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	fhirclient "github.com/SanteonNL/go-fhir-client"
	"github.com/SanteonNL/orca/orchestrator/lib/auth"
	"github.com/google/uuid"
	"net/http"
	"strings"

	"github.com/SanteonNL/orca/orchestrator/careplanservice/careteamservice"
	"github.com/SanteonNL/orca/orchestrator/lib/coolfhir"
	"github.com/SanteonNL/orca/orchestrator/lib/to"
	"github.com/rs/zerolog/log"
	"github.com/zorgbijjou/golang-fhir-models/fhir-models/fhir"
)

func (s *Service) handleCreateTask(ctx context.Context, request FHIRHandlerRequest, tx *coolfhir.BundleBuilder) (FHIRHandlerResult, error) {
	log.Info().Msg("Creating Task")
	var task fhir.Task
	if err := json.Unmarshal(request.ResourceData, &task); err != nil {
		return nil, fmt.Errorf("invalid %T: %w", task, err)
	}

	// Task.id must be generated by the backing FHIR API, so it must be nil in the request
	task.Id = nil

	if !coolfhir.IsScpTask(&task) {
		return nil, coolfhir.NewErrorWithCode("Task is not SCP task", http.StatusBadRequest)
	}

	switch task.Status {
	case fhir.TaskStatusRequested:
	case fhir.TaskStatusReady:
	default:
		return nil, errors.New(fmt.Sprintf("cannot create Task with status %s, must be %s or %s", task.Status, fhir.TaskStatusRequested.String(), fhir.TaskStatusReady.String()))
	}

	principal, err := auth.PrincipalFromContext(ctx)
	if err != nil {
		return nil, err
	}

	carePlan := fhir.CarePlan{}
	var carePlanRef *string
	err = coolfhir.ValidateTaskRequiredFields(task)
	if err != nil {
		return nil, err
	}

	// Enrich Task.Requester and Task.Owner with info from CSD (if available), typically to add the organization name
	// TODO: CSD is queried again later, to get the notification endpoint. We should optimize/cache this. Maybe in the context.Context?
	if entity, err := s.profile.CsdDirectory().LookupEntity(ctx, *task.Requester.Identifier); err != nil {
		log.Info().Err(err).Msgf("Unable to lookup Task.requester in CSD, won't be enriched.")
	} else {
		task.Requester = entity
	}
	if entity, err := s.profile.CsdDirectory().LookupEntity(ctx, *task.Owner.Identifier); err != nil {
		log.Info().Err(err).Msgf("Unable to lookup Task.owner in CSD, won't be enriched.")
	} else {
		task.Owner = entity
	}

	// Resolve the CarePlan
	if task.BasedOn == nil || len(task.BasedOn) == 0 {
		// The CarePlan does not exist, a CarePlan and CareTeam will be created and the requester will be added as a member

		// In order to create a CarePlan, the requester must have the same URA number as the current node
		ids, err := s.profile.Identities(ctx)
		if err != nil {
			return nil, err
		}
		if !isRequesterLocalCareOrganization(ids, principal) {
			return nil, errors.New("requester must be local care organization in order to create new CarePlan and CareTeam")
		}

		// Create a new CarePlan (which will also create a new CareTeam) based on the Task reference
		carePlanURL := "urn:uuid:" + uuid.NewString()
		careTeamURL := "urn:uuid:" + uuid.NewString()
		taskURL := "urn:uuid:" + uuid.NewString()
		careTeam := fhir.CareTeam{}
		carePlan.CareTeam = append(carePlan.CareTeam, fhir.Reference{
			Reference: to.Ptr(careTeamURL),
			Type:      to.Ptr(coolfhir.ResourceType(careTeam)),
		})
		carePlan.Intent = fhir.CarePlanIntentOrder
		carePlan.Activity = append(carePlan.Activity, fhir.CarePlanActivity{
			Reference: &fhir.Reference{
				Reference: to.Ptr(taskURL),
				Type:      to.Ptr(coolfhir.ResourceType(task)),
			},
		})
		carePlan.Category = []fhir.CodeableConcept{
			{
				Coding: []fhir.Coding{
					{
						System: to.Ptr("http://snomed.info/sct"),
						Code:   to.Ptr("135411000146103"),
					},
				},
			},
		}

		// Validate Task.For: identifier (with system and value), and/or reference must be set
		if task.For == nil || !coolfhir.ValidateReference(*task.For) {
			return nil, coolfhir.NewErrorWithCode(fmt.Sprintf("Task.For must be set with a local reference, or a logical identifier, referencing a patient"), http.StatusBadRequest)
		}
		// TODO: INT-450 - Re-enable task.For dereferencing logical identifiers to actual patient, when Frontend is fixed.
		//if task.For.Reference == nil {
		//	headers := fhirclient.Headers{}
		//	patients, _, err := handleSearchResource[fhir.Patient](s, "Patient", map[string][]string{"identifier": {fmt.Sprintf("%s|%s", *task.For.Identifier.System, *task.For.Identifier.Value)}}, &headers)
		//	if err != nil {
		//		return nil, err
		//	}
		//	if len(patients) == 0 {
		//		return nil, coolfhir.NewErrorWithCode("Task.For must be set with a local reference, or a logical identifier, referencing an existing patient", http.StatusNotFound)
		//	}
		//
		//	task.For.Reference = to.Ptr("Patient/" + *patients[0].Id)
		//}
		carePlan.Subject = *task.For
		carePlan.Status = fhir.RequestStatusActive

		task.BasedOn = []fhir.Reference{
			{
				Type:      to.Ptr(coolfhir.ResourceType(carePlan)),
				Reference: to.Ptr(carePlanURL),
			},
		}

		ok := careteamservice.ActivateMembership(&careTeam, &fhir.Reference{
			Identifier: &principal.Organization.Identifier[0],
			Type:       to.Ptr("Organization"),
		})
		if !ok {
			return nil, errors.New("failed to activate membership for new CareTeam")
		}

		tx.Create(carePlan, coolfhir.WithFullUrl(carePlanURL)).
			Create(careTeam, coolfhir.WithFullUrl(careTeamURL)).
			Create(task, coolfhir.WithFullUrl(taskURL))
	} else {
		// Adding a task to an existing CarePlan
		carePlanRef, err = basedOn(task)
		if err != nil {
			return nil, fmt.Errorf("invalid Task.basedOn: %w", err)
		}

		var careTeams []fhir.CareTeam
		err = s.fhirClient.Read(*carePlanRef, &carePlan, fhirclient.ResolveRef("careTeam", &careTeams))
		if err != nil {
			return nil, err
		}

		// Different validation logic for an SCP subtask
		if len(task.PartOf) > 0 {
			if len(task.PartOf) != 1 {
				return nil, coolfhir.NewErrorWithCode("SCP subtask must have exactly one parent task", http.StatusBadRequest)
			}
			// Get the parent task
			var parentTask fhir.Task
			err = s.fhirClient.Read(*task.PartOf[0].Reference, &parentTask)
			if err != nil {
				return nil, err
			}
			// Verify the owner of the parent task is the same as the org creating the subtask
			isOwner, _ := coolfhir.IsIdentifierTaskOwnerAndRequester(&parentTask, principal.Organization.Identifier)
			if !isOwner {
				return nil, coolfhir.NewErrorWithCode("requester is not the owner of the parent task", http.StatusUnauthorized)
			}

			if !coolfhir.LogicalReferenceEquals(*parentTask.Owner, *task.Requester) {
				return nil, coolfhir.NewErrorWithCode("requester is not the same as the parent task owner", http.StatusBadRequest)
			}
			if !coolfhir.LogicalReferenceEquals(*parentTask.Requester, *task.Owner) {
				return nil, coolfhir.NewErrorWithCode("owner is not the same as the parent task requester", http.StatusBadRequest)
			}
		} else {
			// we have a valid reference to a CarePlan, use this to retrieve the CarePlan and CareTeam to validate the requester is a participant
			if len(careTeams) == 0 {
				return nil, coolfhir.NewErrorWithCode("CareTeam not found in bundle", http.StatusNotFound)
			}

			participant := coolfhir.FindMatchingParticipantInCareTeam(careTeams, principal.Organization.Identifier)
			if participant == nil {
				return nil, coolfhir.NewErrorWithCode("requester is not part of CareTeam", http.StatusUnauthorized)
			}
		}
		// TODO: Manage time-outs properly
		// Add Task to CarePlan.activities
		taskBundleEntry := request.bundleEntryWithResource(task)
		if taskBundleEntry.FullUrl == nil {
			taskBundleEntry.FullUrl = to.Ptr("urn:uuid:" + uuid.NewString())
		}
		err = s.newTaskInExistingCarePlan(tx, taskBundleEntry, task, &carePlan)
	}
	if err != nil {
		return nil, fmt.Errorf("failed to create Task: %w", err)
	}
	return func(txResult *fhir.Bundle) (*fhir.BundleEntry, []any, error) {
		var createdTask fhir.Task
		result, err := coolfhir.FetchBundleEntry(s.fhirClient, txResult, func(_ int, entry fhir.BundleEntry) bool {
			if entry.Response.Location == nil {
				return false
			}
			// HAPI uses relative Location URLs, Microsoft Azure FHIR uses absolute URLs.
			createdResourceLocation := *entry.Response.Location
			createdResourceLocation = strings.TrimPrefix(createdResourceLocation, s.fhirURL.String())
			// depending on the base URL ending with slash or not, we might end up with a leading slash.
			// Trim it for deterministic comparison.
			createdResourceLocation = strings.TrimPrefix(createdResourceLocation, "/")
			if strings.HasPrefix(createdResourceLocation, "Task/") {
				// Consistent behavior for easier testing: always pass the relative resource URL to the FHIR client
				entry.Response.Location = to.Ptr(createdResourceLocation)
				return true
			}
			return false
		}, &createdTask)
		if err != nil {
			return nil, nil, err
		}
		var notifications = []any{&createdTask}
		// If CareTeam was updated, notify about CareTeam
		var updatedCareTeam fhir.CareTeam
		if err := coolfhir.ResourceInBundle(txResult, coolfhir.EntryIsOfType("CareTeam"), &updatedCareTeam); err == nil {
			notifications = append(notifications, &updatedCareTeam)
		}

		return result, []any{&createdTask}, nil
	}, nil
}

// newTaskInExistingCarePlan creates a new Task and references the Task from the CarePlan.activities.
func (s *Service) newTaskInExistingCarePlan(tx *coolfhir.BundleBuilder, taskBundleEntry fhir.BundleEntry, task fhir.Task, carePlan *fhir.CarePlan) error {
	// TODO: Only if not updated
	tx.AppendEntry(taskBundleEntry)
	if len(task.PartOf) == 0 {
		// Don't add subtasks to CarePlan.activity
		carePlan.Activity = append(carePlan.Activity, fhir.CarePlanActivity{
			Reference: &fhir.Reference{
				Reference: taskBundleEntry.FullUrl,
				Type:      to.Ptr("Task"),
			},
		})
		tx.Update(*carePlan, "CarePlan/"+*carePlan.Id)
	}
	if _, err := careteamservice.Update(s.fhirClient, *carePlan.Id, task, tx); err != nil {
		return fmt.Errorf("failed to update CarePlan: %w", err)
	}
	return nil
}

// basedOn returns the CarePlan reference the Task is based on, e.g. CarePlan/123.
func basedOn(task fhir.Task) (*string, error) {
	if len(task.BasedOn) != 1 {
		return nil, errors.New("Task.basedOn must have exactly one reference")
	} else if task.BasedOn[0].Reference == nil || !strings.HasPrefix(*task.BasedOn[0].Reference, "CarePlan/") {
		return nil, errors.New("Task.basedOn must contain a relative reference to a CarePlan")
	}
	return task.BasedOn[0].Reference, nil
}

func isRequesterLocalCareOrganization(profileIdentities []fhir.Identifier, principal auth.Principal) bool {
	for _, id := range profileIdentities {
		for _, poid := range principal.Organization.Identifier {
			if coolfhir.IdentifierEquals(&id, &poid) {
				return true
			}
		}
	}
	return false
}
