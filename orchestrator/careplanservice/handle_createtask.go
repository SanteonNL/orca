package careplanservice

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strings"

	fhirclient "github.com/SanteonNL/go-fhir-client"
	"github.com/SanteonNL/orca/orchestrator/lib/auth"
	"github.com/google/uuid"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"

	"github.com/SanteonNL/orca/orchestrator/careplanservice/careteamservice"
	"github.com/SanteonNL/orca/orchestrator/lib/coolfhir"
	"github.com/SanteonNL/orca/orchestrator/lib/to"
	"github.com/rs/zerolog/log"
	"github.com/zorgbijjou/golang-fhir-models/fhir-models/fhir"
)

func (s *Service) handleCreateTask(ctx context.Context, request FHIRHandlerRequest, tx *coolfhir.BundleBuilder) (FHIRHandlerResult, error) {
	tracer := otel.Tracer(tracerName)
	ctx, span := tracer.Start(
		ctx,
		"handleCreateTask",
		trace.WithSpanKind(trace.SpanKindServer),
		trace.WithAttributes(
			attribute.String("fhir.resource_type", "Task"),
			attribute.String("operation.name", "CreateTask"),
		),
	)
	defer span.End()

	log.Ctx(ctx).Info().Msg("Creating Task")
	var task fhir.Task
	if err := json.Unmarshal(request.ResourceData, &task); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "failed to unmarshal task")
		return nil, fmt.Errorf("invalid %T: %w", task, coolfhir.BadRequestError(err))
	}

	// Task is owned by CPS, don't allow changing or setting the source of the Task
	if task.Meta != nil {
		task.Meta.Source = nil
	}

	// Check we're only allowing secure external literal references
	if err := validateLiteralReferences(ctx, s.profile, &task); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "literal reference validation failed")
		return nil, err
	}

	// Task.id must be generated by the backing FHIR API, so it must be nil in the request
	task.Id = nil

	if !coolfhir.IsScpTask(&task) {
		err := coolfhir.NewErrorWithCode("Task is not SCP task", http.StatusBadRequest)
		span.RecordError(err)
		span.SetStatus(codes.Error, "task is not SCP task")
		return nil, err
	}

	switch task.Status {
	case fhir.TaskStatusRequested:
	case fhir.TaskStatusReady:
	default:
		err := errors.New(fmt.Sprintf("cannot create Task with status %s, must be %s or %s", task.Status, fhir.TaskStatusRequested.String(), fhir.TaskStatusReady.String()))
		span.RecordError(err)
		span.SetStatus(codes.Error, "invalid task status")
		return nil, err
	}

	carePlan := fhir.CarePlan{}
	err := coolfhir.ValidateTaskRequiredFields(task)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "task validation failed")
		return nil, err
	}

	if !isPrincipalTaskRequester(&task, request.Principal) {
		err := coolfhir.BadRequest("requester must be equal to Task.requester")
		span.RecordError(err)
		span.SetStatus(codes.Error, "principal is not task requester")
		return nil, err
	}

	// Enrich Task.Requester and Task.Owner with info from CSD (if available), typically to add the organization name
	// TODO: CSD is queried again later, to get the notification endpoint. We should optimize/cache this. Maybe in the context.Context?
	if entity, err := s.profile.CsdDirectory().LookupEntity(ctx, *task.Requester.Identifier); err != nil {
		log.Ctx(ctx).Info().Err(err).Msgf("Unable to lookup Task.requester in CSD, won't be enriched.")
	} else {
		task.Requester = entity
	}
	if entity, err := s.profile.CsdDirectory().LookupEntity(ctx, *task.Owner.Identifier); err != nil {
		log.Ctx(ctx).Info().Err(err).Msgf("Unable to lookup Task.owner in CSD, won't be enriched.")
	} else {
		task.Owner = entity
	}

	// Resolve the CarePlan
	var (
		taskEntryIdx           = -1
		taskBundleEntry        fhir.BundleEntry
		carePlanBundleEntryIdx = -1
		carePlanBundleEntry    *fhir.BundleEntry
	)

	fhirClient := s.fhirClientByTenant[request.Tenant.ID]
	if task.BasedOn == nil || len(task.BasedOn) == 0 {
		// The CarePlan does not exist, a CarePlan and CareTeam will be created and the requester will be added as a member
		span.SetAttributes(attribute.String("fhir.careplan.creation_mode", "new"))

		// In order to create a CarePlan, the requester must have the same URA number as the current node
		ids, err := s.profile.Identities(ctx)
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, "failed to get profile identities")
			return nil, err
		}
		if !isRequesterLocalCareOrganization(ids, *request.Principal) {
			err := errors.New("requester must be local care organization in order to create new CarePlan and CareTeam")
			span.RecordError(err)
			span.SetStatus(codes.Error, "requester is not local care organization")
			return nil, err
		}

		// Create a new CarePlan (which will also create a new CareTeam) based on the Task reference
		carePlanURL := "urn:uuid:" + uuid.NewString()
		careTeamID := "cps-careteam"
		taskURL := "urn:uuid:" + uuid.NewString()
		careTeam := fhir.CareTeam{Id: to.Ptr(careTeamID)}
		carePlan.CareTeam = append(carePlan.CareTeam, fhir.Reference{
			Reference: to.Ptr("#" + careTeamID),
			Type:      to.Ptr(coolfhir.ResourceType(careTeam)),
		})
		carePlan.Intent = fhir.CarePlanIntentOrder
		carePlan.Activity = append(carePlan.Activity, fhir.CarePlanActivity{
			Reference: &fhir.Reference{
				Reference: to.Ptr(taskURL),
				Type:      to.Ptr(coolfhir.ResourceType(task)),
			},
		})
		carePlan.Category = []fhir.CodeableConcept{
			{
				Coding: []fhir.Coding{
					{
						System:  to.Ptr("http://snomed.info/sct"),
						Code:    to.Ptr("135411000146103"),
						Display: to.Ptr("Multidisciplinary care regime"),
					},
				},
			},
		}

		// Validate Task.For: identifier (with system and value), and/or reference must be set
		if task.For == nil || !coolfhir.ValidateReference(*task.For) {
			err := coolfhir.NewErrorWithCode("Task.For must be set with a local reference, or a logical identifier, referencing a patient", http.StatusBadRequest)
			span.RecordError(err)
			span.SetStatus(codes.Error, "invalid task.for reference")
			return nil, err
		}
		if task.For.Reference == nil {
			headers := fhirclient.Headers{}
			patients, _, err := handleSearchResource[fhir.Patient](ctx, fhirClient, "Patient", map[string][]string{"identifier": {fmt.Sprintf("%s|%s", *task.For.Identifier.System, *task.For.Identifier.Value)}}, &headers)
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, "failed to search for patient")
				return nil, err
			}

			if len(patients) == 0 {
				err := coolfhir.NewErrorWithCode("Task.For must be set with a local reference, or a logical identifier, referencing an existing patient", http.StatusNotFound)
				span.RecordError(err)
				span.SetStatus(codes.Error, "patient not found")
				return nil, err
			} else {
				task.For.Reference = to.Ptr("Patient/" + *patients[0].Id)
			}
		}

		ok := careteamservice.ActivateMembership(&careTeam, task.Requester)
		if !ok {
			err := errors.New("failed to activate membership for new CareTeam")
			span.RecordError(err)
			span.SetStatus(codes.Error, "failed to activate care team membership")
			return nil, err
		}

		data, err := json.Marshal([]any{careTeam})
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, "failed to marshal care team")
			return nil, coolfhir.NewErrorWithCode("failed to marshal CareTeam", http.StatusInternalServerError)
		}

		carePlan.Subject = *task.For
		carePlan.Status = fhir.RequestStatusActive
		carePlan.Author = task.Requester
		carePlan.Contained = data
		// This is technically not needed, but adding it for the sake of data consistency
		carePlan.Extension = []fhir.Extension{
			{
				Url: CreatorExtensionURL,
				ValueReference: &fhir.Reference{
					Type:       to.Ptr("Organization"),
					Identifier: task.Requester.Identifier,
				},
			},
		}

		task.BasedOn = []fhir.Reference{
			{
				Type:      to.Ptr(coolfhir.ResourceType(carePlan)),
				Reference: to.Ptr(carePlanURL),
			},
		}
		task.Extension = []fhir.Extension{
			{
				Url: CreatorExtensionURL,
				ValueReference: &fhir.Reference{
					Type:       to.Ptr("Organization"),
					Identifier: task.Requester.Identifier,
				},
			},
		}

		carePlanBundleEntryIdx = len(tx.Entry)
		tx.Create(carePlan, coolfhir.WithFullUrl(carePlanURL), coolfhir.WithAuditEvent(ctx, tx, coolfhir.AuditEventInfo{
			ActingAgent: &fhir.Reference{
				Identifier: task.Requester.Identifier,
				Type:       to.Ptr("Organization"),
			},
			Observer: *request.LocalIdentity,
			Action:   fhir.AuditEventActionC,
		}))
		carePlanBundleEntry = &tx.Entry[carePlanBundleEntryIdx]

		taskEntryIdx = len(tx.Entry)
		tx.Create(task, coolfhir.WithFullUrl(taskURL), coolfhir.WithRequestHeaders(request.HttpHeaders), coolfhir.WithAuditEvent(ctx, tx, coolfhir.AuditEventInfo{
			ActingAgent: &fhir.Reference{
				Identifier: task.Requester.Identifier,
				Type:       to.Ptr("Organization"),
			},
			Observer: *request.LocalIdentity,
			Action:   fhir.AuditEventActionC,
		}))
		taskBundleEntry = tx.Entry[taskEntryIdx]
		if s.eventManager.HasSubscribers(CarePlanCreatedEvent{}) {
			if err := s.eventManager.Notify(ctx, CarePlanCreatedEvent{
				CarePlan: carePlan,
			}); err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, "failed to notify care plan created event")
				return nil, err
			}
		}
	} else {
		// Adding a task to an existing CarePlan
		span.SetAttributes(attribute.String("fhir.careplan.creation_mode", "existing"))

		carePlanRef, err := basedOn(task)
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, "invalid task.basedOn")
			return nil, fmt.Errorf("invalid Task.basedOn: %w", err)
		}

		var carePlan fhir.CarePlan

		if err := fhirClient.ReadWithContext(ctx, *carePlanRef, &carePlan); err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, "failed to read care plan")
			return nil, fmt.Errorf("failed to read CarePlan: %w", err)
		}

		if task.For == nil {
			err := coolfhir.NewErrorWithCode("Task.For must be set with a local reference, or a logical identifier, referencing a patient", http.StatusBadRequest)
			span.RecordError(err)
			span.SetStatus(codes.Error, "task.for is required")
			return nil, err
		}

		task.Extension = []fhir.Extension{
			{
				Url: CreatorExtensionURL,
				ValueReference: &fhir.Reference{
					Type:       to.Ptr("Organization"),
					Identifier: task.Requester.Identifier,
				},
			},
		}

		samePatient := false
		// If either task.For or CarePlan.Subject contains an identifier, they must be equal
		// If neither contain an identifier, the reference must be equal
		if task.For.Identifier != nil || carePlan.Subject.Identifier != nil {
			samePatient = coolfhir.LogicalReferenceEquals(*task.For, carePlan.Subject)
		} else {
			samePatient = coolfhir.ReferenceValueEquals(*task.For, carePlan.Subject)
		}

		if !samePatient {
			err := coolfhir.NewErrorWithCode("Task.for must reference the same patient as CarePlan.subject", http.StatusBadRequest)
			span.RecordError(err)
			span.SetStatus(codes.Error, "task.for does not match careplan.subject")
			return nil, err
		}

		// Different validation logic for an SCP subtask
		if len(task.PartOf) > 0 {
			span.SetAttributes(attribute.String("fhir.task.type", "subtask"))

			if len(task.PartOf) != 1 {
				err := coolfhir.NewErrorWithCode("SCP subtask must have exactly one parent task", http.StatusBadRequest)
				span.RecordError(err)
				span.SetStatus(codes.Error, "subtask must have exactly one parent")
				return nil, err
			}
			// Get the parent task
			var parentTask fhir.Task
			err = fhirClient.ReadWithContext(ctx, *task.PartOf[0].Reference, &parentTask)
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, "failed to read parent task")
				return nil, err
			}
			// Verify the owner of the parent task is the same as the org creating the subtask
			isOwner, _ := coolfhir.IsIdentifierTaskOwnerAndRequester(&parentTask, request.Principal.Organization.Identifier)
			if !isOwner {
				err := coolfhir.NewErrorWithCode("requester is not the owner of the parent task", http.StatusUnauthorized)
				span.RecordError(err)
				span.SetStatus(codes.Error, "requester is not parent task owner")
				return nil, err
			}

			if !coolfhir.LogicalReferenceEquals(*parentTask.Owner, *task.Requester) {
				err := coolfhir.NewErrorWithCode("requester is not the same as the parent task owner", http.StatusBadRequest)
				span.RecordError(err)
				span.SetStatus(codes.Error, "requester mismatch with parent task owner")
				return nil, err
			}
			if !coolfhir.LogicalReferenceEquals(*parentTask.Requester, *task.Owner) {
				err := coolfhir.NewErrorWithCode("owner is not the same as the parent task requester", http.StatusBadRequest)
				span.RecordError(err)
				span.SetStatus(codes.Error, "owner mismatch with parent task requester")
				return nil, err
			}
		} else {
			span.SetAttributes(attribute.String("fhir.task.type", "primary"))

			careTeam, err := coolfhir.CareTeamFromCarePlan(&carePlan)
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, "failed to parse care team from care plan")
				return nil, fmt.Errorf("failed to parse CareTeam in CarePlan.Contained: %w", err)
			}

			participant := coolfhir.FindMatchingParticipantInCareTeam(careTeam, request.Principal.Organization.Identifier)
			if participant == nil {
				err := coolfhir.NewErrorWithCode("requester is not part of CareTeam", http.StatusUnauthorized)
				span.RecordError(err)
				span.SetStatus(codes.Error, "requester not in care team")
				return nil, err
			}
		}

		// TODO: Manage time-outs properly
		// Add Task to CarePlan.activities
		taskBundleEntry = request.bundleEntryWithResource(task)
		if taskBundleEntry.FullUrl == nil {
			taskBundleEntry.FullUrl = to.Ptr("urn:uuid:" + uuid.NewString())
		}

		taskEntryIdx = len(tx.Entry)
		// TODO: Only if not updated
		tx.AppendEntry(taskBundleEntry, coolfhir.WithAuditEvent(ctx, tx, coolfhir.AuditEventInfo{
			ActingAgent: &fhir.Reference{
				Identifier: task.Requester.Identifier,
				Type:       to.Ptr("Organization"),
			},
			Observer: *request.LocalIdentity,
			Action:   fhir.AuditEventActionC,
		}))

		if len(task.PartOf) == 0 {
			// Don't add subtasks to CarePlan.activity
			carePlan.Activity = append(carePlan.Activity, fhir.CarePlanActivity{
				Reference: &fhir.Reference{
					Reference: taskBundleEntry.FullUrl,
					Type:      to.Ptr("Task"),
				},
			})

			updated, err := careteamservice.Update(ctx, fhirClient, *carePlan.Id, task, request.LocalIdentity, tx)
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, "failed to update care team")
				return nil, fmt.Errorf("failed to update CareTeam: %w", err)
			}

			carePlanBundleEntryIdx = len(tx.Entry)
			if !updated {
				tx.Update(carePlan, "CarePlan/"+*carePlan.Id, coolfhir.WithAuditEvent(ctx, tx, coolfhir.AuditEventInfo{
					ActingAgent: &fhir.Reference{
						Identifier: task.Requester.Identifier,
						Type:       to.Ptr("Organization"),
					},
					Observer: *request.LocalIdentity,
					Action:   fhir.AuditEventActionU,
				}))
			}
			carePlanBundleEntry = &tx.Entry[carePlanBundleEntryIdx]
		}
	}

	span.SetStatus(codes.Ok, "")
	span.SetAttributes(attribute.String("fhir.task.creation", "success"))

	return func(txResult *fhir.Bundle) ([]*fhir.BundleEntry, []any, error) {
		var result *fhir.BundleEntry
		var notifications []any

		// Task
		{
			var createdTask fhir.Task
			var err error
			result, err = coolfhir.NormalizeTransactionBundleResponseEntry(ctx, fhirClient, request.BaseURL, &taskBundleEntry, &txResult.Entry[taskEntryIdx], &createdTask)
			if err != nil {
				return nil, nil, err
			}
			notifications = append(notifications, &createdTask)
		}

		// If CarePlan was updated/created, notify about CarePlan
		if carePlanBundleEntry != nil {
			var createdCarePlan fhir.CarePlan
			_, err = coolfhir.NormalizeTransactionBundleResponseEntry(ctx, fhirClient, request.BaseURL, carePlanBundleEntry, &txResult.Entry[carePlanBundleEntryIdx], &createdCarePlan)
			if err != nil {
				return nil, nil, err
			}
			notifications = append(notifications, &createdCarePlan)
		}

		return []*fhir.BundleEntry{result}, notifications, nil
	}, nil
}

// basedOn returns the CarePlan reference the Task is based on, e.g. CarePlan/123.
func basedOn(task fhir.Task) (*string, error) {
	if len(task.BasedOn) != 1 {
		return nil, errors.New("Task.basedOn must have exactly one reference")
	} else if task.BasedOn[0].Reference == nil || !strings.HasPrefix(*task.BasedOn[0].Reference, "CarePlan/") {
		return nil, errors.New("Task.basedOn must contain a relative reference to a CarePlan")
	}
	return task.BasedOn[0].Reference, nil
}

func isRequesterLocalCareOrganization(localIdentities []fhir.Organization, principal auth.Principal) bool {
	for _, localIdentity := range localIdentities {
		for _, requesterIdentifier := range principal.Organization.Identifier {
			for _, localIdentifier := range localIdentity.Identifier {
				if coolfhir.IdentifierEquals(&localIdentifier, &requesterIdentifier) {
					return true
				}
			}
		}
	}
	return false
}

func isPrincipalTaskRequester(task *fhir.Task, principal *auth.Principal) bool {
	if task.Requester == nil || task.Requester.Identifier == nil {
		return false
	}
	for _, identifier := range principal.Organization.Identifier {
		if coolfhir.IdentifierEquals(task.Requester.Identifier, &identifier) {
			return true
		}
	}
	return false
}
